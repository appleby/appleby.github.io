<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>app.leby.org</title>
    <link>https://app.leby.org/</link>
    <description>Recent content on app.leby.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 02 Apr 2018 14:55:08 -0500</lastBuildDate>
    
	<atom:link href="https://app.leby.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Appleby, elsewhere</title>
      <link>https://app.leby.org/elsewhere/</link>
      <pubDate>Wed, 01 May 2019 18:13:53 -0500</pubDate>
      
      <guid>https://app.leby.org/elsewhere/</guid>
      <description>This page contains links to external code snippets and interactive notebooks and the like that I have posted around the web.
 TADM2e Heap Compare a Google Colab notebook that contains a Python program to count and plot the number of nodes visited by the heap_compare function presented in The Algorithm Design Manual (2nd Ed.) Generating All Min Heaps a Google Colab notebook that contains several implementations of a routine to generate all distinct min heaps on N={0,1,2,…,n−1}.</description>
    </item>
    
    <item>
      <title>Hire Appleby</title>
      <link>https://app.leby.org/hireme/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 -0500</pubDate>
      
      <guid>https://app.leby.org/hireme/</guid>
      <description>If you&#39;re reading this, you probably received from me a resume or an email inquiring about a job. The purpose of this page is to provide a bit more context about me than will fit on a resume, in order to help you decided whether or not you want to interview me. You can find a copy of my resume here.
Who am I? I am a software engineer with approximately 5 years of professional experience in the network security sector.</description>
    </item>
    
    <item>
      <title>Fun with Parenscript</title>
      <link>https://app.leby.org/post/fun-with-parenscript/</link>
      <pubDate>Fri, 04 May 2018 00:00:00 -0500</pubDate>
      
      <guid>https://app.leby.org/post/fun-with-parenscript/</guid>
      <description>About this post This post is a stream-of-consciousness rambling as I kick the tires of Parenscript. This is my first time using Parenscript. See the Parenscript homepage for docs, tutorials and the like. The lisp code in this post was only tested on SBCL, but in theory should work with any lisp implementation that Parenscript supports.
About Parenscript Parenscript is a Common Lisp library that compiles a subset of Common Lisp down to dependency-free, readable JavaScript.</description>
    </item>
    
    <item>
      <title>All About Appleby</title>
      <link>https://app.leby.org/about/</link>
      <pubDate>Fri, 06 Apr 2018 11:36:29 -0500</pubDate>
      
      <guid>https://app.leby.org/about/</guid>
      <description>About app.leby.org This website is generated from a mixture of markdown and org-mode files using the Hugo static site generator and my own hugo-ugly theme. I used to use a snazzy, modern-looking hugo theme, but then I got nostalgic for the old internet, where personal pages were uglier but also more personal and a little bit weirder. Someday I will go the whole hog and ditch Hugo and just write good-old HTML, the way God and Tim Berners-Lee intended.</description>
    </item>
    
    <item>
      <title>Lisp In Small Pieces</title>
      <link>https://app.leby.org/notes/lisp/</link>
      <pubDate>Fri, 19 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://app.leby.org/notes/lisp/</guid>
      <description>Ch. 1 The Basics of Interpretation &amp;sect; 1.3 Evaluating Atoms Syntactic vs. Semantic Elements (define (evaluate expr env) (if (and (atom? expr) (symbol? expr)) (lookup expr env) ...  To be more precise, we could instead write:
(lookup (symbol-&amp;gt;variable expr) env)  and likewise, taking the abstraction one step further:
(lookup (variable-&amp;gt;key (symbol-&amp;gt;variable expr)) env)  However, when writing a meta-circular evaluator we normally rely on the fact that we can represent the concept of a &amp;ldquo;variable&amp;rdquo; in our source language and &amp;ldquo;key&amp;rdquo; in our defining language both as ordinary lisp symbols.</description>
    </item>
    
    <item>
      <title>Uniprocessor Garbage Collection Techniques</title>
      <link>https://app.leby.org/notes/gc-survey/</link>
      <pubDate>Sun, 20 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://app.leby.org/notes/gc-survey/</guid>
      <description>Overview This page contains notes on a paper by Paul R. Wilson titled, &amp;ldquo;Uniprocessor Garbage Collection Techniques&amp;rdquo;.
&amp;sect; 2 Basic Garbage Collection Techniques &amp;sect; 2.1 Reference Counting Pros  Incremental nature of operations makes it suitable for real time applications. Space efficient, able to operate with very low space overhead. Garbage typically collected immediately, which can be beneficial for object finalizers. May improve locality of reference. Easier to implement than full gc.</description>
    </item>
    
    <item>
      <title>Hints on Programming Language Design</title>
      <link>https://app.leby.org/notes/hoare-hints/</link>
      <pubDate>Wed, 25 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>https://app.leby.org/notes/hoare-hints/</guid>
      <description>Overview This page contains notes on a paper by C.A.R. Hoare titled, &amp;ldquo;Hints on Programming Language Design.&amp;rdquo; Here is a summary of the major points that jumped out at me.
Hoare is for:
 Languages that aid the programmer in design, documentation, and debugging Small, simple designs Static analysis and typing Safety (bounds checking, etc.) Fast compilation and efficient code Readability Dumpable images A superb comment convention! Mutable state (for efficiency) Type extensions + operator overloading Consolidating best of existing features when designing a new language  Hoare is against:</description>
    </item>
    
    <item>
      <title>Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part 1</title>
      <link>https://app.leby.org/notes/recursive/</link>
      <pubDate>Wed, 14 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://app.leby.org/notes/recursive/</guid>
      <description>&amp;sect; 2 Functions and Function Definitions Introduces the notion of a conditional expression!
Tidbit: McCarthy proposed the addition of a cond-like expression to Algol 60, but it was rejected in favor of the English equivalent, if ... then ... else.
Review of concepts:
 a. Partial Function a function that is only defined on part of it&amp;rsquo;s domain. b. Propositional Expressions and Predicates $T, F, \wedge, \lor, \lnot, etc.$ c.</description>
    </item>
    
  </channel>
</rss>