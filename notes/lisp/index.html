<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.20.2" />
  <meta name="author" content="Mike Appleby">
  

  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/github.min.css">
    
  
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/academicons.min.css">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono">
  <link rel="stylesheet" href="/css/hugo-academic.css">
  

  <link rel="alternate" href="https://app.leby.org/index.xml" type="application/rss+xml" title="appleby">
  <link rel="feed" href="https://app.leby.org/index.xml" type="application/rss+xml" title="appleby">

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="https://app.leby.org/notes/lisp/">

  

  <title>Notes: Lisp In Small Pieces | appleby</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">appleby</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/notes/">
            
            <span>Notes</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#contact">
            
            <span>Contact</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  

  <div class="article-container">
    <h1 itemprop="name">Notes: Lisp In Small Pieces</h1>
    

<div class="article-metadata">

  <span class="article-date">
    <time datetime="2014-09-19 00:00:00 &#43;0000 UTC" itemprop="datePublished">
      Fri, Sep 19, 2014
    </time>
  </span>

  
  
  
  

  
  
  
  

  
  

  

</div>

    <div class="article-style" itemprop="articleBody">
      

<h1 id="ch-1-the-basics-of-interpretation">Ch. 1 The Basics of Interpretation</h1>

<h2 id="sect-1-3-evaluating-atoms">&sect; 1.3 Evaluating Atoms</h2>

<h4 id="syntactic-vs-semantic-elements">Syntactic vs. Semantic Elements</h4>

<pre><code class="language-scheme">(define (evaluate expr env)
    (if (and (atom? expr) (symbol? expr))
        (lookup expr env)
        ...
</code></pre>

<p>To be more precise, we could instead write:</p>

<pre><code class="language-scheme">        (lookup (symbol-&gt;variable expr) env)
</code></pre>

<p>and likewise, taking the abstraction one step further:</p>

<pre><code class="language-scheme">        (lookup (variable-&gt;key (symbol-&gt;variable expr)) env)
</code></pre>

<p>However, when writing a meta-circular evaluator we normally rely on the fact
that we can represent the concept of a &ldquo;variable&rdquo; in our source language and
&ldquo;key&rdquo; in our defining language both as ordinary lisp symbols.</p>

<h4 id="autoquote">Autoquote</h4>

<blockquote>
<p>When an expression is atomic &hellip; and when that expression is not a symbol, we
have the habit of considering it as the representation of a constant that is
its own value. This idempotence is known as the <em>autoquote</em> facility. An
autoquoted object does not need to be quoted, and it is its own value.</p>
</blockquote>

<h2 id="sect-1-4-evaluating-forms">&sect; 1.4 Evaluating Forms</h2>

<h3 id="sect-1-4-2-alternatives">&sect; 1.4.2 Alternatives</h3>

<h4 id="more-on-syntactic-vs-semantic-elements">More on Syntactic vs. Semantic Elements</h4>

<p>As above, the following snippet of code can be made more explicit by replacing:</p>

<pre><code class="language-scheme">... (case (car e) ...
        ((if (if (evaluate (cadr e) env)
                 (evaluate (caddr e) env)
                 (evaluate (cadddr e) env))))
        ...
</code></pre>

<p>with</p>

<pre><code class="language-scheme">(define the-false-value (cons &quot;false&quot; &quot;boolean&quot;)

... (case (car e) ...
        ((if (if (not (eq? (evaluate (cadr e) env) the-false-value))
                 (evaluate (caddr e) env)
                 (evaluate (cadddr e) env))))
        ...
</code></pre>

<p>Again, such pedantry is not really necessary for a meta-circular eval, but it&rsquo;s
useful to keep in mind that you&rsquo;re using a kind of shorthand when you implement
it as in the first snippet.</p>

<h2 id="sect-1-5-representing-the-environment">&sect; 1.5 Representing the Environment</h2>

<h4 id="fail-fast">Fail Fast</h4>

<blockquote>
<p>The goal of a program is not so much to avoid committing errors but rather to
fulfill its duty. &hellip; Errors and erroneous contexts need to be pointed out as
early as possible so that their source can be corrected as soon as possible.</p>
</blockquote>

<h2 id="sect-1-6-representing-functions">&sect; 1.6 Representing Functions</h2>

<h3 id="sect-1-6-1-dynamic-and-lexical-binding">&sect; 1.6.1 Dynamic and Lexical Binding</h3>

<blockquote>
<p>In a lexical Lisp, a function evaluates its body in its own definition
environment extended by its variables, whereas in a dynamic Lisp, a function
extends the current environment, that is, the environment of the application.</p>
</blockquote>

<p>Something to consider when designing a language: do you want to support</p>

<ul>
<li>only lexical bindings (<em>Ã  la</em> Scheme)</li>
<li>both lexical and dynamic bindings with the same syntax (Common Lisp)</li>
<li>both, but with two separate, syntactically distinguished namespaces (EULisp,
ISLisp).</li>
</ul>

<p>McCarthy pondered the meaning of</p>

<pre><code class="language-scheme">(let ((a 1))
  ((let ((a 2))
    (lambda (b) (list a b))) 3))
</code></pre>

<p>And realized he expected <code>(2 3)</code>, not <code>(1 3)</code>. So he introduced a special form
called <code>function</code> in Lisp 1.0 for creating closures, i.e. in <code>(function (lambda
() x))</code>, <code>x</code> would be lexically bound in the definition environment. But
lexical environments offer a big advantage in compiled code, namely that the
compiler can generate efficient code for variable access, rather than
dynamically searching the environment at runtime. So in Lisp 1.5, they made
lexical scope the default and introduced <code>(declare (special x))</code> to indicate a
variable that should be dynamically scoped.</p>

<h3 id="sect-1-6-2-deep-or-shallow-implementation">&sect; 1.6.2 Deep or Shallow Implementation</h3>

<dl>
<dt>Deep Binding</dt>
<dd>doing a linear search through an alist (or similar) to find the dynamic
 binding.</dd>
<dt>Shallow Binding</dt>
<dd>associating the value of the variable directly with the symbol that
 represents it (i.e. store it on the symbol p-list). This avoids a linear
 search for the value at the cost of uglying up function calls, since
 functions must save/restore bindings, which interferes with TCO.</dd>
</dl>

<h1 id="ch-2-lisp-1-2-omega">Ch. 2 Lisp, 1, 2, &hellip; &omega;</h1>

<h2 id="sect-2-2-lisp-sub-2-sub">&sect; 2.2 Lisp<sub>2</sub></h2>

<p>Lisp<sub>2</sub> allows the evaluator to take a shortcut. When evaluating the
function position of an application, we can restrict it to a symbol and do a
simple lookup rather than a full eval. That is</p>

<pre><code class="language-scheme">(define (evaluate e env)
  (if (atom? e) ...
    (case (car e) ...
      ((lambda) (make-function (cadr e) (cddr e) env))
      (else (invoke (evaluate (car e) env)
                    (evlis (cdr e) env))))))
</code></pre>

<p>can be replaced with</p>

<pre><code class="language-scheme">      ...
      (else (invoke (lookup (car e) env)
                    (evlis (cdr e) env)))...
</code></pre>

<p>or, if we want to allow <code>lambda</code> in the function position as well as a symbol,
we can replace the <code>lookup</code> with a call to <code>evaluate-application</code>, a mini eval
that knows how to handle lambdas and symbol lookup.</p>

<pre><code class="language-scheme">(define (evaluate-application fn args env fenv)
  (cond ((symbol? fn) ((lookup fn fenv) args))
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn) (extend env (cadr fn) args) fenv))
        (else (wrong &quot;Incorrect functional term&quot; fn))))
</code></pre>

<p>Lisp<sub>2</sub> has the advantage of making function lookups faster, since we
don&rsquo;t force another call to eval, but instead do the lookup directly, and also
because the function environment will be more compact since it does not contain
variable bindings. In addition, lambda forms in function position are greatly
simplified. Consider:</p>

<pre><code class="language-scheme">(let ((state-tax 1.186))
  ((lambda (x) (* state-tax x)) (read)))
</code></pre>

<p>In the above case, the closure corresponding to the lambda will not be created,
rather its body will be evaluated in the correct environment. We can also avoid
checking that the symbol in the function position is indeed a function at
application time if we perform the check before binding it.</p>

<p>However, many of these apparent advantages of Lisp<sub>2</sub> can be overcome
in Lisp<sub>1</sub> if the function to apply can be determined statically,
which is usually the case.</p>

<p>On the down side, with Lisp<sub>2</sub> we lose the ability to calculate the
function to apply, as in <code>((if cond + -) 3 4)</code>.</p>

<h3 id="sect-2-2-2-duality-of-the-two-worlds">&sect; 2.2.2 Duality of the Two Worlds</h3>

<p>I.e., the two worlds of functions vs. evaluations.</p>

<blockquote>
<p>To summarize these problems, we should say that there are calculations
belonging to the parametric world that we want to carry out in the
functional world, and vice versa. More precisely, we may want to pass a
function as an argument or as a result, or we may even want the function that
will be applied to be the result of a lengthy calculation.</p>

<p>The function <code>funcall</code> lets us take the result of a calculation coming from
the parametric world and put it into the function world as a value.
Conversely, the special form <code>function</code> (a.k.a. <code>#'</code>) lets us get the value
of a variable from the function world.</p>
</blockquote>

<h2 id="sect-2-5-name-spaces">&sect; 2.5 Name Spaces</h2>

<h3 id="sect-2-5-3-dynamic-variables-without-a-special-form">&sect; 2.5.3 Dynamic Variables without a Special Form</h3>

<p>One can have dynamic binding without special forms, so long the interpreter has
been modified to pass the current dynamic environment to functions. All that is
needed then is to introduce functions <code>bind/de</code> and <code>assoc/de</code> to bind /
reference dynamic vars.</p>

<pre><code class="language-scheme">(bind/de 'x 2
  (lambda () (+ (assoc/de 'x error)
                  (let ((x (+ (assoc/de 'x error) (assoc/de 'x error))))
                    (+ x (assoc/de 'x error))))))
--&gt; 8
</code></pre>

<p>This has the advantage of not requiring extra special forms, but the
disadvantage of being hideous to read/type.</p>

<h2 id="sect-2-6-recursion">&sect; 2.6 Recursion</h2>

<h3 id="sect-2-6-1-simple-recursion">&sect; 2.6.1 Simple Recursion</h3>

<pre><code class="language-scheme">(define (display-pi)
  (display pi))

(define pi 2.71828)

(define (print-pi)
  (display pi))

(define pi 3.14159)
</code></pre>

<p>What is the value of <code>(display-pi)</code>? Of <code>(print-pi)</code>?</p>

<h3 id="sect-2-6-6-recursion-without-assignment">&sect; 2.6.6 Recursion without Assignment</h3>

<h4 id="paradoxical-combinator">Paradoxical Combinator</h4>

<div>
$$
\begin{align*}
\exists \textbf{Y}, \forall F, \textbf{Y}F &= F(\textbf{Y}F) \\
\textbf{Y} &= \textbf{WW} \\
\textbf{W} &= \lambda \textbf{W} . \lambda F . F ((\textbf{W W}) F)
\end{align*}
$$
</div>

<p>or, in a normal-order lisp:</p>

<pre><code class="language-scheme">(let ((W (lambda (w)
            (lambda (f)
               (f ((w w) f)) ) )))
   (W W) )
</code></pre>

<p>Scheme uses call-by-value, so we add an $\eta$-conversion to prevent
evaluation of the <code>((w w) f)</code> term.</p>

<pre><code class="language-scheme">(define fix
  (let ((d (lambda (w)
              (lambda (f)
                 (f (lambda (x) (((w w) f) x))) ) )))
     (d d) ) )
</code></pre>

<p>We can then define factorial as:</p>

<pre><code class="language-scheme">(define fact
   (fix (lambda (fact)
           (lambda (n)
              (if (= n 0)
                 1
                 (* n (fact (- n 1))) ) ) )) )
</code></pre>

<h1 id="ch-3-escape-return-continuations">Ch. 3 Escape &amp; Return: Continuations</h1>

<p>The original escape form in Lisp 1.5 was <code>prog</code>. <code>prog</code> allows
declaring local variables, followed by a sequence of labels and
instructions. The instruction may contain <code>go</code> forms, which cause
unconditional jumps to uncomputed labels, and a <code>return</code> form, which
specifies the return value for the whole <code>prog</code> form. In Lisp 1.5,
<code>go</code> and <code>return</code> forms could only appear in the first level of a
<code>prog</code> or in a <code>cond</code> at the first level.</p>

<pre><code class="language-commonlisp">(defun fact (n)
  (prog (r)
         (setq r 1)
    loop (cond ((= n 1) (return r)))
         (setq r (* n r))
         (setq n (- n 1))
         (go loop)))
</code></pre>

<h2 id="sect-3-1-forms-for-handling-continuations">&sect; 3.1 Forms for Handling Continuations</h2>

<h3 id="sect-3-1-1-the-pair-catch-throw">&sect; 3.1.1 The Pair <code>catch</code>/<code>throw</code></h3>

<pre><code class="language-scheme">(catch label forms ...)

(throw label form)
</code></pre>

<ul>
<li>Dynamic extent.</li>
<li>Label bound in dynamic environment.</li>
<li>Labels evaluated.</li>
</ul>

<h3 id="sect-3-1-2-the-pair-block-return-from">&sect; 3.1.2 The Pair <code>block</code>/<code>return-from</code></h3>

<pre><code class="language-scheme">(block label forms ...)

(return-from label form)
</code></pre>

<ul>
<li>Dynamic extent.</li>
<li>Label bound in lexical environment.</li>
<li>Labels not evaluated.</li>
</ul>

<h3 id="sect-3-1-3-escapes-with-a-dynamic-extent">&sect; 3.1.3 Escapes with a Dynamic Extent</h3>

<pre><code class="language-scheme">((block foo (lambda (x) (return-from foo x))) 33) --&gt; error

(block foo
  (let ((f1 (lambda (x) (return-from foo x))))
    (* 2 (block foo (f1 1)))))
--&gt; 1

(catch 'foo
  (let ((f1 (lambda (x) (throw 'foo x))))
    (* 2 (catch 'foo (f1 1)))))
--&gt; 2
</code></pre>

<h3 id="sect-3-1-5-escapes-with-indefinite-extent">&sect; 3.1.5 Escapes with Indefinite Extent</h3>

<p><em>A la</em> Scheme&rsquo;s <code>call/cc</code>.</p>

<pre><code class="language-scheme">(call/cc (lambda (k) (+ 1 (k 2)))) --&gt; 2
</code></pre>

<blockquote>
<p>The last choice due to Scheme is to not create a new type of
object and thus to represent continuations by unary functions,
indistinguishable from function created by <code>lambda</code>. The
continuation <em>k</em> is thus <em>reified</em>, that is, turned into an object
that becomes the value of <code>k</code>&hellip;</p>

<p>Another solution would be to create another type of object,
namely, continuations themselves. This type would be distinct from
functions, and would necessitate a special invoker, namely,
<code>continue</code>. The preceding example would then be rewritten like this:</p>
</blockquote>

<pre><code class="language-scheme">(call/cc (lambda (k) (+ 1 (continue k 2)))) --&gt; 2
</code></pre>

<p>I think I fall into this camp.</p>

<blockquote>
<p>Some people like calls to continuations that are syntactically eye-opening
because they make alteration of the thread of control more evident.</p>
</blockquote>

<p>Here is <code>fact</code>, implemented via <code>call/cc</code>.</p>

<pre><code class="language-scheme">(define (fact n)
  (let ((r 1))
    (let ((k (call/cc (lambda (c) c))))
      (set! r (* r n))
      (set! n (- n 1))
      (if (= n 1) r (k k)))))
</code></pre>

<h2 id="sect-3-2-actors-in-a-computation">&sect; 3.2 Actors in a Computation</h2>

<h3 id="sect-3-2-5-sequence">&sect; 3.2.5 Sequence</h3>

<p>A little implementation hack for <code>begin</code> forms in the
continuation-based interpreter.</p>

<pre><code class="language-scheme">(define (evaluate-begin e* r k)
  ...(evaluate (car e*) r (make-begin-cont k e* r))...)

(define-method (resume (k begin-cont) v)
  (evaluate-begin (cdr (begin-cont-e* k)) ...))
</code></pre>

<p>The cdr of <code>e*</code> is taken in <code>resume</code> rather than in <code>evaluate-begin</code>,
so that one can tell which expression is in flight by examining the
continuation.</p>

<h2 id="sect-3-3-initializing-the-interpreter">&sect; 3.3 Initializing the Interpreter</h2>

<p>Is this sarcasm? I doubt it, but it got a chuckle out of me
nonetheless. More likely something fell through the cracks in the
translation from French.</p>

<blockquote>
<p>Notice that the entire interpreter could easily be written in a real
object-language, like Smalltalk, so we could take advantage of its
famous browser and debugger. The only thing left to do is to add
whatever is needed to open a lot of little windows everywhere.</p>
</blockquote>

<h2 id="sect-3-4-implementing-control-forms">&sect; 3.4 Implementing Control Forms</h2>

<h3 id="sect-3-4-4-implementation-of-unwind-protect">&sect; 3.4.4 Implementation of <code>unwind-protect</code></h3>

<p>Curious bit of trivia, CLtL2 introduced the restriction that an escape
in a cleanup form couldn&rsquo;t unwind <em>less far</em> than the escape currently
underway. In other words, the following was an error:</p>

<pre><code class="language-commonlisp">(catch 1
  (catch 2
    (unwind-protect (throw 1 'foo)
	  (throw 2 'bar))))

--&gt; error
</code></pre>

<p>This restriction was apparently lifted in ANSI Common Lisp (the
hyperspec doesn&rsquo;t mention it, and SBCL happily returns <code>BAR</code>).</p>

<h2 id="sect-3-5-comparing-call-cc-to-catch">&sect; 3.5 Comparing <code>call/cc</code> to <code>catch</code></h2>

<blockquote>
<p>In the world of Scheme, continuations can no longer be put on the
stack because they can be kept in external data structures. Thus we
have to adopt another model: a hierarchic model, sometimes called a
<em>cactus stack</em>. The most naive approach is to leave the stack and
allocate blocks for continuations directly in the heap&hellip; [but] the
canonical implementation of <code>call/cc</code> copies the stack into the
heap; the continuation is thus this very copy of the stack.</p>
</blockquote>

<h2 id="sect-3-7-partial-continuations">&sect; 3.7 Partial Continuations</h2>

<p>This section describes a variant called partial continuations, which
are continuations that act like function calls in so far as they
return their value to the current continuation. With standard
continuations:</p>

<pre><code class="language-scheme">(+ 1 (call/cc (lambda (k) (set! foo k) 2)))
--&gt; 3
(foo (foo 4))
--&gt; 5
</code></pre>

<p>If foo were a partial continuation, the result of <code>(foo (foo 4))</code>
would be 6, not 5.</p>

<h2 id="sect-3-9-exercises">&sect; 3.9 Exercises</h2>

<h3 id="exercise-3-10">Exercise 3.10</h3>

<p>Meditate on the following:</p>

<pre><code class="language-scheme">(define (make-box value)
  (let ((box
         (call/cc
          (lambda (exit)
            (letrec
               ((behavior
                 (call/cc
                  (lambda (store)
                    (exit (lambda (msg . new)
                            (call/cc
                             (lambda (caller)
                               (case msg
                                 ((get) (store (cons (car behavior)
                                                     caller)))
                                 ((set)
                                  (store
                                   (cons (car new)
                                         caller))))))))))))
              ((cdr behavior) (car behavior)))))))
    (box 'set value)
    box))
</code></pre>

<h1 id="ch-4-assignment-and-side-effects">Ch. 4 Assignment and Side Effects</h1>

<h2 id="sect-4-5-semantics-of-quotations">&sect; 4.5 Semantics of Quotations</h2>

<p>The following quote is essentially a continuation on the theme first
presented in the sections <em>Syntactic vs. Semantic Elements</em> and <em>More
on Syntactic vs. Semantic Elements</em>, above. That is, a distinction
between objects and values in the definition language, as opposed to
the defined language.</p>

<blockquote>
<p>In the end, we can accept a compositional definition of quoting
since, by transforming the program, we can revert to our usual
habits. However, we might scrutinize these bad habits that depend on
the fact that programs are often read with the function <code>read</code> and
that thus the expression that appears in a <code>quote</code> and that
specifies the immediate data to return is coded with the same
conventions: same dotted pairs, same symbols, etc. Natural laziness
impinges on the interpreter to use this same value and thus to
return it every time it&rsquo;s needed.</p>
</blockquote>

<h1 id="ch-5-denotational-semantics">Ch. 5 Denotational Semantics</h1>

<p>The introduction lists a variety of ways to specify the semantics of a
language:</p>

<ul>
<li><p><em>Reference Implementation</em> is probably the most common technique, in
which a reference implemenation is the <em>de facto</em> standard to which
any other implementation should conform. Think Python.</p></li>

<li><p><em>Operational Semantics</em> involves precisely specifying a virtual
machine and it&rsquo;s operations, and defining the meaning of a program
or language in terms of how it&rsquo;s translated into instruction for the
virtual machine. Think MMIX.</p></li>

<li><p><em>Denotational Semantics</em> &ldquo;consists of defining (for a given
language) a function, called the <em>valuation</em>, that associates each
valid program of the language with a term in the denotation space,&rdquo;
called its <em>denotation</em>. Usually, the $\lambda$-calculus is target
language for the denotation. &ldquo;The denotation of a program is the
$\lambda$-term representing its meaning.&rdquo;</p></li>

<li><p><em>Axiomatic Semantics</em> were introduced by Floyd and Hoare. The idea
is to define for each elementary form of the language a logical
formula: ${P}form{Q}$ which indicates that if $P$ is true before
$form$ executes, then $Q$ is true after. Axiomatic semantics are
thus useful for attempting to prove that program is correct, but not
especially useful for constructing an implementation of a given
language.</p></li>

<li><p><em>Natural Semantics</em> &ldquo;favors relations (over functions) in a context
derived from denotational semantics.&rdquo;</p></li>

<li><p><em>Algebraic Semantics</em> &ldquo;reasons in terms of equivalent programs by
means of rewrite rules.&rdquo;</p></li>
</ul>

<h2 id="sect-5-1-a-brief-review-of-lambda-calculus">&sect; 5.1 A Brief Review of $\lambda$-Calculus</h2>

<p>The set of terms in the $\lambda$-calculus is given by $\Lambda$,
which can be defined recursively as:</p>

<div>
$$
\begin{align}
\textrm{variable}&:    \forall x \in \textbf{Variable},                         & x \in \Lambda \\
\textrm{abstraction}&: \forall x \in \textbf{Variable}, \forall M \in \Lambda,  & \lambda x.M \in \Lambda \\
\textrm{combination}&: \forall M, N \in \Lambda,                                & (M N) \in \Lambda
\end{align}
$$
</div>

<p>$\beta$-reduction occurs during an application when the parameters of
a combination are substituted for some value in the body of the
combination. E.g.</p>

<div>
$$
\beta\textrm{-reduction}: (\lambda x. M \;\; N) \overset{\beta}{\to} M[x \to N]
$$
</div>

<p>A <em>redex</em> is a <strong>red</strong>ucible <strong>ex</strong>pression, i.e. an application in
which the first term is an abstraction. A $\beta$-reduction supresses
a redex.</p>

<blockquote>
<p>When a term contains no redex&hellip;, we say that the term is in <em>normal
form</em>. Terms in $\lambda$-calculus do no necessarily have a normal
form, but when they have one, it is unique because of the
Church-Rosser property.  When a term has a normal form, there exists
a finite series of $\beta$-reductions that convert the original term
into the normal form. An <em>evaluation rule</em> is a procedure that
indicates which redex (if there is more than one) ought to be
$\beta$-reduced.</p>
</blockquote>

<p>Common examples of evaluation rules are <em>normal order</em> (aka <em>call by
name</em>), <em>call by need</em>, and <em>call by value</em>. Scheme uses the latter
for efficiency reasons. Normal order is so named becaues it&rsquo;s
guaranteed to find the normal form, if it exists, whereas call by
value is not. Consider, for example:</p>

<div>
$$
((\lambda x.\lambda y.y \; (\omega \, \omega)) \: z) \\
\textrm{where} \ \omega = \lambda x.(x \, x)
$$
</div>

<p>In a normal-order language, the above $\beta$-reduces to $z$, whereas
in Scheme, the $(\omega \, \omega)$ term causes an infinite loop.</p>

<h2 id="sect-5-2-semantics-of-scheme">&sect; 5.2 Semantics of Scheme</h2>

<div>
$$
\begin{align}
\textrm{evaluate}&: \textbf{Program} \times \textbf{Environment} \times
\textbf{Continuation} \times \textbf{Memory} \to \textbf{Value} \\
\textrm{valuation}&: \textbf{Program} \to \textbf{Denotation} \\
\textbf{Denotation}&: \textbf{Environment} \times \textbf{Continuation} \times
\textbf{Memory} \to \textbf{Value}
\end{align}
$$
</div>

<p>The following define various domains of objects handled by
denotations.</p>

<div>
$$
\begin{align}
\textbf{Environment} &= \textbf{Identifier} \to \textbf{Address} \\
\textbf{Memory} &= \textbf{Address} \to \textbf{Value} \\
\textbf{Value} &= \textbf{Function} + \textbf{Boolean} + \textbf{Integer} + \textbf{Pair} + \ldots \\
\textbf{Continuation} &= \textbf{Value} \times \textbf{Memory} \to \textbf{Value} \\
\textbf{Function} &= \textbf{Value}* \times \textbf{Continuation} \times \textbf{Memory} \to \textbf{Value}
\end{align}
$$
</div>

<p>And some greek letters that customarily represent the domains.</p>

<div>
$$
\begin{array}{r l | r l}
\pi & \textbf{Program} & \rho & \textbf{Environment} \\
\nu & \textbf{Identifier} & \alpha & \textbf{Address} \\
\sigma & \textbf{Memory} & \epsilon & \textbf{Value} \\
\kappa & \textbf{Continuation} & \varphi & \textbf{Function}
\end{array}
$$
</div>

<blockquote>
<p><em>Extensionality</em> is the property that $(\forall x, f(x) = g(x))
\implies (f = g)$. It is linked to the $\eta$-conversion&hellip;</p>
</blockquote>

<div>
$$
\eta\textrm{-conversion}: \lambda x.(M \;\; x) \overset{\eta}{\to} M
\;\; \textrm{with x not free in M}
$$
</div>

<p>The denotation of a tiny scheme (missing variable airity, <em>etc.</em>). The
denotation of <code>call/cc</code> is included in the book. I&rsquo;ve left it out here
because it&rsquo;s too tedious to typeset.</p>

<div>
$$
\begin{align}
\mathcal{E}[\nu] &= \lambda \rho \kappa \sigma.(\kappa \: (\sigma \: (\rho \: \nu)) \: \sigma) \\
\mathcal{E}[(\textbf{set!} \; \nu \: \pi)]\rho \kappa \sigma &= (\mathcal{E}[\pi] \: \rho \: \lambda \epsilon \sigma_{1}.(\kappa \: \epsilon \: \sigma_{1}[(\rho \: \nu) \to \epsilon]) \: \sigma) \\
\mathcal{E}[(\textbf{if} \; \pi \; \pi_{1} \; \pi_{2})]\rho \kappa \sigma &=
  (\mathcal{E}[\pi] \: \rho \: \lambda \epsilon \sigma_{1}.(\textit{boolify} \: \epsilon)
  \to (\mathcal{E}[\pi_{1} \: \rho \: \kappa \: \sigma_{1}) \| (\mathcal{E}[\pi_{2}] \: \rho \: \kappa \: \sigma_{1}) \: \sigma) \\
\mathcal{E}[(\textbf{lambda} \: (\nu^*) \: \pi^+)]\rho \kappa \sigma &=
(\kappa \: \textbf{inValue}(\lambda \epsilon^* \kappa_1 \sigma_1.\# \epsilon^* = \# \nu^*
\to \textit{allocate} \: \sigma_1 \: \# \nu^* \: \lambda \sigma_2 \alpha^*.(\mathcal{E}^+[\pi^+] \: \rho [\nu^* \overset{*}{\to} \alpha^*] \: \kappa_1 \: \sigma_2[\alpha^* \overset{*}{\to} \epsilon^*])
\| \textit{wrong} \: \textrm{``Incorrect arity''}) \: \sigma) \\
\mathcal{E}[(\pi \: \pi^*)]\rho \kappa \sigma &= (\mathcal{E}[\pi] \: \rho \: \lambda \varphi \sigma_1.(\mathcal{E}^*[\pi^*] \: \rho \: \lambda \epsilon^*\sigma_2.(\varphi|_{Function} \: \epsilon^* \: \kappa \: \sigma_2) \: \sigma_1) \: \sigma) \\
\mathcal{E}[\pi \: \pi^*]\rho \kappa \sigma &= (\mathcal{E}[\pi] \: \rho \: \lambda \epsilon \sigma_1.(\mathcal{E}^*[\pi^*] \: \rho \: \lambda \epsilon^*\sigma_2.(\kappa \: \langle \epsilon \rangle:\epsilon^* \: \sigma_2) \: \sigma_1) \: \sigma) \\
\mathcal{E}[]\rho \kappa \sigma &= (\kappa \: \langle \rangle \: \sigma) \\
\mathcal{E}[(begin \: \pi^+)]\rho \kappa \sigma &= (\mathcal{E}^+[\pi^+] \: \rho \: \kappa \: \sigma) \\
\mathcal{E}^+[\pi]\rho \kappa \sigma &= (\mathcal{E}[\pi] \: \rho \: \kappa \: \sigma) \\
\mathcal{E}^+[\pi \: \pi^+]\rho \kappa \sigma &= (\mathcal{E}[\pi] \: \rho \: \lambda \epsilon \sigma_1.(\mathcal{E}^+[\pi^+] \: \rho \: \kappa \: \sigma_1) \: \sigma)
\end{align}
$$
</div>

<p>For comparison, here is the denotation given for the
$\lambda$-calculus.</p>

<div>
$$
\begin{align}
\mathcal{L}[\nu]\rho &= (\rho \: \nu)\\
\mathcal{L}[(\textbf{lambda} \: (\nu) \: \pi)]\rho &= \lambda \epsilon.(\mathcal{L}[\pi] \rho[\nu \to \epsilon])\\
\mathcal{L}[(\pi \: \pi^\prime)]\rho &= ((\mathcal{L} \: \rho)(\mathcal{L}[\pi^\prime] \: \rho))
\end{align}
$$
</div>

<h1 id="ch-6-fast-interpretation">Ch. 6 Fast Interpretation</h1>

<h2 id="sect-6-1-a-fast-interpreter">&sect; 6.1 A Fast Interpreter</h2>

<h3 id="6-1-1-migration-of-denotations">6.1.1 Migration of Denotations</h3>

<p><em>$\lambda$-hoisting</em> or <em>$\lambda$-drifting</em> means migrating code out
of the body of a lambda, to precompute as much as possible and capture
those values in the closed environment, to avoid having to recompute
the values every time the function is called. Not to be confused with
<em>$\lambda$-lifting</em>.</p>

<h1 id="ch-10-compiling-into-c">Ch. 10 Compiling into C</h1>

<h2 id="sect-10-4-eliminating-nested-functions">&sect; 10.4 Eliminating Nested Functions</h2>

<blockquote>
<p>As a language, C does not support functions inside other
functions. In other words, a <code>lambda</code> inside another <code>lambda</code> cannot
be translated directly. Consequently, we must eliminate these cases
in a way that turns the program to compile into a simple set of
closed functions, that is, funcitons without free variables. Once
again, we&rsquo;re lucky to find such a natural transformation. We&rsquo;ll call
it <code>lambda</code>-<em>lifting</em> because it makes <code>lambda</code> forms migrate
towards the exterior in such a way that there are no remaining
<code>lambda</code> forms in the interior.</p>
</blockquote>

    </div>
  </div>

</article>

<div class="container">
  <nav>
  <ul class="pager">
    
    <li class="previous"><a href="https://app.leby.org/notes/gc-survey/"><span
      aria-hidden="true">&larr;</span> Notes: Uniprocessor Garbage Collection Techniques</a></li>
    

    
  </ul>
</nav>

</div>

<div class="article-container">
  

</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      

      Powered by the <a href="https://github.com/gcushen/hugo-academic" target="_blank">Academic
      theme</a> for <a href="http://gohugo.io" target="_blank">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>

    <script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.4/TweenMax.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/gsap/latest/plugins/ScrollToPlugin.min.js"></script>
    <script src="/js/jquery-1.12.3.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/isotope.pkgd.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.1/imagesloaded.pkgd.min.js"></script>
    <script src="/js/hugo-academic.js"></script>
    

    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-89952512-1', 'auto');
        ga('send', 'pageview');

         
        var links = document.querySelectorAll('a');
        Array.prototype.map.call(links, function(item) {
            if (item.host != document.location.host) {
                item.addEventListener('click', function() {
                    var action = item.getAttribute('data-action') || 'follow';
                    ga('send', 'event', 'outbound', action, item.href);
                });
            }
        });
    </script>
    

    
    
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>

      

      
      
        
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scheme.min.js"></script>
        
      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script>
    <script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
    

  </body>
</html>

