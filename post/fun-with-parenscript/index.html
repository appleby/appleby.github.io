<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-04-12 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fun with Parenscript</title>
<meta name="description" content="A stream-of-consciousness rambling as I kick the tires of Parenscript" />
<meta name="keywords" content="parenscript, lisp, javascript" />
<meta name="generator" content="Org Mode" />
<link rel="icon" type="image/png" href="/img/icon.png">
<link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">
<style type="text/css">
<!--/*--><![CDATA[/*><!--*/
#postamble p, #preamble p { font-size: 90%; margin: .2em; }
.footpara { display: inline; }
.footdef  { margin-bottom: 1em; }
/*]]>*/-->
</style>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Fun with Parenscript</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#about-this-post">About this post</a></li>
<li><a href="#about-parenscript">About Parenscript</a></li>
<li><a href="#a-parenscript-crash-course">A Parenscript crash course</a></li>
<li><a href="#pre-compiling-parenscript-for-static-sites">Pre-compiling Parenscript for static sites</a></li>
<li><a href="#three-easy-pieces">Three easy pieces</a>
<ul>
<li><a href="#example-1-toggling-dom-content">Example 1: Toggling DOM content</a></li>
<li><a href="#example-2-fun-with-svg">Example 2: Fun with SVG</a></li>
<li><a href="#example-3-fun-with-plotly.js">Example 3: Fun with Plotly.js</a>
<ul>
<li><a href="#example-3.1-plotly-bar-chart">Example 3.1: Plotly bar chart</a></li>
<li><a href="#example-3.2-plotly-choropleth">Example 3.2: Plotly choropleth</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#bugs-oddities">Bugs &amp; Oddities</a>
<ul>
<li><a href="#reduce-sometimes-ignores-its-init-argument"><code>reduce</code> sometimes ignores its <code>init</code> argument</a></li>
<li><a href="#let-ignores-garbage-in-binding-forms"><code>let</code> ignores garbage in binding forms</a></li>
<li><a href="#psencode-js-identifier-deprecation-warnings"><code>ps::encode-js-identifier</code> deprecation warnings</a></li>
<li><a href="#array-argument-punning">Array argument punning</a></li>
<li><a href="#vs"><code>[]</code> vs <code>{}</code></a></li>
</ul>
</li>
<li><a href="#takeaways">Takeaways</a>
<ul>
<li><a href="#pros">Pros</a></li>
<li><a href="#cons">Cons</a></li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-about-this-post" class="outline-2">
<h2 id="about-this-post">About this post</h2>
<div class="outline-text-2" id="text-about-this-post">
<p>
This post is a stream-of-consciousness rambling as I kick the tires of
Parenscript. This is my first time using Parenscript. See the
<a href="https://common-lisp.net/project/parenscript/">Parenscript</a> homepage for docs, tutorials and the like. The lisp code
in this post was only tested on SBCL, but in theory should work with
any lisp implementation that Parenscript supports.
</p>
</div>
</div>

<div id="outline-container-about-parenscript" class="outline-2">
<h2 id="about-parenscript">About Parenscript</h2>
<div class="outline-text-2" id="text-about-parenscript">
<p>
<a href="https://common-lisp.net/project/parenscript/">Parenscript</a> is a Common Lisp library that compiles a subset of Common
Lisp down to dependency-free, readable JavaScript. In the wider world
of compile-to-js languages, Parenscript is a niche market, but it has
a few "features" that I like.
</p>

<ol class="org-ol">
<li>It's Common Lisp, so there's that.</li>
<li>You can share Parenscript code between the client and server, if
you're running Common Lisp on the server.</li>
<li>No runtime dependencies. Compiles down to vanilla JS (version 1.3
by default, but you can pick your poison with
<code>*js-target-version*</code>).</li>
<li>There is no need for boilerplate or type definitions if you want to
call JavaScript code.</li>
<li>I get the impression that Parenscript, much like Common Lisp, is
more-or-less "done." Not "done" in the sense of bug-free and
perfect, but in the sense that breaking changes (or any changes,
for that matter) are rarely made. The older I get, the more I like
stable things.</li>
</ol>

<p>
Except for #1, these points are not necessarily unique to Parenscript,
but, honestly, #1 was enough to make me want to try it out.
</p>
</div>
</div>

<div id="outline-container-a-parenscript-crash-course" class="outline-2">
<h2 id="a-parenscript-crash-course">A Parenscript crash course</h2>
<div class="outline-text-2" id="text-a-parenscript-crash-course">
<p>
This section will present a bare-minimum introduction to the parts of
Parenscript necessary to understand the code presented in this
post. See the official <a href="https://common-lisp.net/project/parenscript/tutorial.html">Parenscript tutorial</a> for more info.
</p>

<p>
One of the nice things about Parenscript is that it's basically the
thinnest possible abstraction for transpiling lisp to JavaScript, so
most of the the time you can guess what JavaScript will be produced
for a given Parenscript expression. Here are few simple examples, with
the Parenscript on the left and the corresponding JavaScript to the
right. Note that the first top-level comment is just for
clarification. Parenscript comments are not actually copied to the
compiled JavaScript.
</p>

<pre class="example" id="orgd43dec7">
<code>;; Parenscript                        /* JavaScript */</code>
<code>(defvar *my-global* 1234)             var MYGLOBAL = 1234;</code>
<code></code>
<code>(defun say-hello (name)               function sayHello(name) {</code>
<code>  (alert (concatenate                    return alert('Hello ' + name);</code>
<code>           'string "Hello " name)))   };</code>
<code></code>
<code>(defun foo (x)                        /** Add 42 to x. */</code>
<code>  "Add 42 to x."                      function foo(x) {</code>
<code>  (let ((y 42))                          var y = 42;</code>
<code>    (+ x y)))                            return x + y;</code>
<code>                                      };</code>
<code></code>
<code>(length '(1 2 3 4))                   [1, 2, 3, 4].length;</code>
<code></code>
<code>some-symbol                           someSymbol;</code>
<code>-some-symbol                          SomeSymbol;</code>
<code></code>
<code>(some-function x y z)                 someFunction(x, y, z);</code>
<code></code>
<code>"hi"                                  'hi';</code>
<code>'hi                                   'hi';</code>
<code>:hi                                   'hi';</code>
</pre>

<p>
Parenscript also includes special forms and macros for creating and
accessing JavaScript objects and arrays. I won't bother typing out an
English explanation of what these do, since they should be obvious
from the examples below. See the <a href="https://common-lisp.net/project/parenscript/reference.html">Parenscript reference</a> for details.
</p>

<pre class="example" id="orgc40eec8">
<code>;; Parenscript                        /* JavaScript */</code>
<code>(defvar *my-array* [])                var MYARRAY = [];</code>
<code></code>
<code>'(1 2 foo)                            [1, 2, 'foo'];</code>
<code>'(1 (2 foo) 3)                        [1, [2, 'foo'], 3];</code>
<code>(list 1 2 foo)                        [1, 2, foo];</code>
<code>(array 1 2 foo)                       [1, 2, foo];</code>
<code>(make-array 1 2 foo)                  new Array(1, 2, foo);</code>
<code>(new (-array 1 2 foo))                new Array(1, 2, foo);</code>
<code></code>
<code>([] 1 2 foo)                          [1, 2, foo];</code>
<code>([] 1 (2 foo) 3)                      [1, [2, foo], 3];</code>
<code>([] 1 (2 foo) (3 (bar bop)))          [1, [2, foo], [3, [bar, bop]]];</code>
<code></code>
<code>(defvar *my-object* {})               var MYOBJECT = {  };</code>
<code></code>
<code>(create)                              ({  });</code>
<code>(create a 1 b "hi")                   ({ a : 1, b : 'hi' });</code>
<code>(create :a 1 :b "hi")                 ({ 'a' : 1, 'b' : 'hi' });</code>
<code>(create 'a 1 'b 'hi)                  ({ 'a' : 1, 'b' : 'hi' });</code>
<code></code>
<code>(getprop obj 'foo)                    obj.foo;</code>
<code>(getprop obj foo)                     obj[foo];</code>
<code>(getprop obj "foo")                   obj['foo'];</code>
<code>(getprop obj :foo)                    obj['foo'];</code>
<code></code>
<code>(@ foo bar baz 3 quux)                foo.bar.baz[3].quux;</code>
<code>(@ foo bar (bop 7))                   foo.bar[bop(7)];</code>
<code></code>
<code>(chain foo bar baz 3 quux)            foo.bar.baz[3].quux;</code>
<code>(chain foo bar (bop 7))               foo.bar.bop(7);</code>
</pre>
</div>
</div>

<div id="outline-container-pre-compiling-parenscript-for-static-sites" class="outline-2">
<h2 id="pre-compiling-parenscript-for-static-sites">Pre-compiling Parenscript for static sites</h2>
<div class="outline-text-2" id="text-pre-compiling-parenscript-for-static-sites">
<p>
Parenscript, being a lisp library, is geared towards a workflow where
you are running Common Lisp on the server and serving up your
Parenscript-compiled JS via hunchentoot or some other lisp-powered
webserver. Here's an example from the <a href="https://common-lisp.net/project/parenscript/tutorial.html">Parenscript tutorial</a>:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(define-easy-handler (example3 :uri "/example3.js") ()</code>
<code>  (setf (content-type*) "text/javascript")</code>
<code>  (ps</code>
<code>    (defun greeting-callback ()</code>
<code>      (alert "Hello World"))))</code>
</pre>
</div>

<p>
Notice that there is no stand-alone, command-line driven program that
takes a Parenscript file as input and produces a JavaScript file as
output. It's a lisp-centric workflow targeting existing Common Lisp
users who are used to being able to seamlessly switch between editing
code and compiling or evaluating forms in a REPL, without the need for
an external compilation or build step. Also, it's reasonable to assume
that one of the main reasons someone might choose Parenscript as their
compile-to-js language of choice is that they are already familiar
with Common Lisp and possibly are looking to avoid subjecting
themselves to the pain of learning one or more of
Webpack/Browserify/Rollup/Gulp/Grunt/NPM/Yarn/Bower, etc. There are
other advantages to the Parenscript workflow beyond familiarity for
Common Lisp users, like the ability to share code between the server
and client side and the ability to call Common Lisp functions at
JavaScript-output time.
</p>

<p>
However, in cases where you don't plan to write any backend code,
so-called "serverless" architectures or static websites (like this
one), it's convenient to be able to emit a JavaScript file at
build-time. Thankfully, Parenscript includes the function
<code>ps-compile-file</code>. It's trivial to write a function that calls
<code>ps-compile-file</code> and writes the output to a new file. For example:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(defun ps-compile-file-to-file (&amp;key (input #P"parenscript.lisp") output)</code>
<code>  (let ((outpath (or output (uiop:make-pathname* :defaults input :type "js"))))</code>
<code>    (uiop:with-enough-pathname (enough-outpath :pathname outpath)</code>
<code>      (with-open-file (*parenscript-stream* enough-outpath :direction :output :if-exists :supersede)</code>
<code>        (ps-compile-file input)))))</code>
</pre>
</div>

<p>
The <code>ps-compile-file-to-file</code> function accepts an <code>:input</code> keyword
argument that should name a file containing Parenscript code that you
want to compile. By default, it will write the JavaScript output to a
file with the same name as <code>input</code>, but with file extension "js".
</p>

<p>
A complete example that you can load in your SLIME REPL is here:
<a href="ps-compile-file.lisp">ps-compile-file.lisp</a>. The comment at the top of that file describes
how to configure emacs to bind <code>ps-compile-file-to-file</code> to a
keybinding or arrange to call it automatically on every buffer
save. If you want to get crazy, you could convert <a href="ps-compile-file.lisp">ps-compile-file.lisp</a>
into a runnable script or executable with something like <a href="https://www.cliki.net/cl-launch">cl-launch</a> or
<a href="https://github.com/roswell/roswell">roswell</a>, and then hook it into your JavaScript build system of
choice. I do not want to get crazy, so it's emacs keybindings for me.
</p>

<p>
The above <code>ps-compile-file-to-file</code> hack is good enough for the
purpose of this post, but if you're doing any serious work in
Parenscript, you might want to check out <a href="https://github.com/johnmastro/trident-mode.el">trident-mode</a>.
</p>

<p>
For reference, all the Parenscript code in this post is included in
the file <a href="parenscript.lisp">parenscript.lisp</a>, and the corresponding JavaScript produced
by <code>ps-compile-file-to-file</code> is in <a href="parenscript.js">parenscript.lisp</a>.
</p>

<p>
Now that I have decent workflow setup for transpiling Parenscript
code, I can start hacking.
</p>
</div>
</div>

<div id="outline-container-three-easy-pieces" class="outline-2">
<h2 id="three-easy-pieces">Three easy pieces</h2>
<div class="outline-text-2" id="text-three-easy-pieces">
</div>

<div id="outline-container-example-1-toggling-dom-content" class="outline-3">
<h3 id="example-1-toggling-dom-content">Example 1: Toggling DOM content</h3>
<div class="outline-text-3" id="text-example-1-toggling-dom-content">
<p>
I'll start with a small program that does something useless. Something
where the implementation is trivial, but with a bit more complexity
than "hello, world" so I can get a feel for Parenscript without
getting bogged down in the implementation details.
</p>

<p>
This is JavaScript, so how about some good-old DHTML? Let's try
toggling some DOM content with a link.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(defun normalize-display (display)</code>
<code>  "Convert the empty string to the string 'block', otherwise return</code>
<code>`display' unmodified."</code>
<code>  (if (string= display "") "block" display))</code>
<code></code>
<code>(defmacro swap (a b)</code>
<code>  "Swap the values of variables `a' and `b'.</code>
<code></code>
<code>Note that `a' and `b' are both evaluated twice, and must be valid</code>
<code>JavaScript l-values."</code>
<code>  (with-ps-gensyms (tmp)</code>
<code>    `(let ((,tmp ,a))</code>
<code>       (setf ,a ,b)</code>
<code>       (setf ,b ,tmp))))</code>
<code></code>
<code>(defun toggle-content (id-a id-b id-link)</code>
<code>  "Toggle the display of the elements given by `id-a' and `id-b'."</code>
<code>  (let* ((link (chain document (get-element-by-id id-link)))</code>
<code>         (element-a (chain document (get-element-by-id id-a)))</code>
<code>         (element-b (chain document (get-element-by-id id-b)))</code>
<code>         (a-display (normalize-display (@ element-a style display)))</code>
<code>         (b-display (normalize-display (@ element-b style display)))</code>
<code>         (link-text (concatenate 'string "Show "</code>
<code>                                 (if (equal a-display "block") id-a id-b)))</code>
<code>         (state (concatenate 'string a-display "," b-display)))</code>
<code>    (when (not (or (equal state "block,none")</code>
<code>                   (equal state "none,block")))</code>
<code>      (throw (concatenate 'string "Invalid state: " state)))</code>
<code>    (swap (@ element-a style display) (@ element-b style display))</code>
<code>    (setf (@ link inner-h-t-m-l) link-text)))</code>
<code></code>
<code>(chain document</code>
<code>       (get-element-by-id "toggle-link")</code>
<code>       (add-event-listener</code>
<code>        "click"</code>
<code>        (lambda (event)</code>
<code>          (chain event (prevent-default))</code>
<code>          (toggle-content "toggle-jelly" "toggle-cat" "toggle-link"))))</code>
</pre>
</div>

<p>
You can see the full source file in <a href="parenscript.lisp">parenscript.lisp</a> and the
corresponding JavaScript in <a href="parenscript.js">parenscript.js</a>. If you want to see the
corresponding HTML, just use your browser's "view source".
</p>

<p>
My first impression of Parenscript is that it feels more like
programming JavaScript with a lispy syntax than it feels like
programming in Common Lisp (fair enough, since I <i>am</i> ultimately
writing JavaScript). For example, if I had been writing Common Lisp,
I'd have probably used a cons to represent the combined <code>a-display</code>
and <code>b-display</code> state tuple. But Parenscript doesn't have <code>cons</code>
because there is no equivalent datastructure in JavaScript. I tried
using a list/array, but in Parenscript <code>equal</code> compiles down to
JavaScript's <code>==</code> operator, which isn't suitable for comparing JS
arrays, so I just serialized the state to a string, which can be
compared directly. Of course, if I was worried about efficiency, I
could have expanded the <code>when</code> conditional to explicitly check
<code>a-display</code> and <code>b-display</code> separately, or, if I was writing Common
Lisp, I could have used a pattern-matching library.
</p>

<p>
The other minor point of interest in the above code is the <code>swap</code>
macro. Common Lisp has <code>rotatef</code>, but Parenscript doesn't so I added
<code>swap</code>. I later realized that Parenscript does define <code>psetf</code>, which
could have been used instead&#x2013;oops! Also, defining a macro for this is
probably overkill, but it was a good excuse to try out Parenscript's
macros.
</p>

<p>
Finally, here is the working example in all its glory. Scroll down a
bit to get the full effect.
</p>

<a id="toggle-link" href="#">Show toggle-cat</a>
<pre id="toggle-jelly">















This space reserved for

    JELLY STAINS!















</pre>
<pre id="toggle-cat" style="display: none">
        .;''-.
      .' |    `._
     /`  ;       `'.
   .'     \         \
  ,'\|    `|         |
  | -'_     \ `'.__,J
 ;'   `.     `'.__.'
 |      `"-.___ ,'
 '-,           /
 |.-`-.______-|
 }      __.--'L
 ;   _,-  _.-"`\         ___
 `7-;"   '  _,,--._  ,-'`__ `.
  |/      ,'-     .7'.-"--.7 |        _.-'
  ;     ,'      .' .'  .-. \/       .'
   ;   /       / .'.-     ` |__   .'
    \ |      .' /  |    \_)-   `'/   _.-'``
     _,.--../ .'     \_) '`_      \'`
   '`f-'``'.`\;;'    ''`  '-`      |
      \`.__. ;;;,   )              /
       `-._,|;;;,, /\            ,'
        / /<_;;;;'   `-._    _,-'
       | '- /;;;;;,      `t'` \. I like nonsense.
       `'-'`_.|,';;;,      '._/| It wakes up the brain cells!
       ,_.-'  \ |;;;;;    `-._/
             / `;\ |;;;,  `"     - Theodor Seuss Geisel -
           .'     `'`\;;, /
          '           ;;;'|
              .--.    ;.:`\    _.--,
             |    `'./;' _ '_.'     |
              \_     `"7f `)       /
              |`   _.-'`t-'`"-.,__.'
              `'-'`/;;  | |   \ mx
</pre>

<p>
There you have it: some DOM content being toggled by
Parenscript. Isn't she glorious?
</p>
</div>
</div>

<div id="outline-container-example-2-fun-with-svg" class="outline-3">
<h3 id="example-2-fun-with-svg">Example 2: Fun with SVG</h3>
<div class="outline-text-3" id="text-example-2-fun-with-svg">
<p>
For this example, I'll try drawing a simple SVG bar chart. The point
of this example is to write more Parenscript, not necessarily to
produce a beautiful plot, so I won't use any 3rd party plotting
package. Instead, I'll write Parenscript to call the SVG DOM API
directly. I'll plot a bar chart of the top 25 US states sorted by
total agriculture exports. Exciting, I know! The data comes from
<a href="https://github.com/plotly/datasets">Plotly's datasets repo</a>, but I've copied it here to try and prevent the
inevitable broken link: <a href="2011_us_ag_exports.csv">2011_us_ag_exports.csv</a>. If your user-agent
supports it, you can hover over the individual bars in the chart to
reveal a tooltip showing the exact values. I've only tested this in
Chrome on Linux and Android, so if the chart looks like a jumbled pile
of nonsense in your browser: <code>¯\_(ツ)_/¯</code>.
</p>

<style type="text/css">
.fetch-warning {
    display: none;
    color: red;
    font-size: 12pt;
    font-weight: bold;
}

.wide-graph {
  width: 100%;
}

@media (min-width: 800px) {
  .wide-graph {
    width: 90%;
  }
}
</style>
<svg id="svg-chart" class="wide-graph">
  Sorry, your browser does not support inline SVG.
</svg>

<p>
The Parenscript code for this example starts by importing the tiny
<a href="https://common-lisp.net/project/parenscript/reference.html#section-runtime-library">Parenscript runtime library</a>, which consists of the following seven
functions: <code>member</code>, <code>map</code>, <code>mapcar</code>, <code>reduce</code>, <code>map-into</code>,
<code>set-difference</code>, and <code>nconc</code>. The <code>lisp</code> form is needed to tell the
Parenscript compiler to evaluate <code>*ps-lisp-library*</code> in the host lisp,
kind of like a comma inside a back-quoted expression.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(lisp *ps-lisp-library*)</code>
</pre>
</div>

<p>
Next, I define some small utilities. In addition to functional
stand-bys like <code>curry</code>, <code>flip</code>, <code>take</code>, and <code>zip</code>, there is the
<code>array</code> function which just returns its arguments as a JS array. Note
that Parenscript already defines <code>array</code> as a special form that
compiles down to a JavaScript array literal, and a macro <code>list</code> which
expands to <code>array</code>. However, it's useful to define a real function for
this that can be passed as an argument to other functions like <code>map</code>
or <code>reduce</code>. The utils are rounded out with a function to sort the CSV
table on a particular column (<code>numeric-sort-by!</code>) and a function to
create a JS object from a sequence of key-value pairs
(<code>make-object-from</code>).
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>;;; You can't actually call this function from Parenscript directly,</code>
<code>;;; since if "array" appears in the car of a sexp, Parenscript</code>
<code>;;; compiles it down to an array literal, like so: (array 1 2 3) --&gt;</code>
<code>;;; [1,2,3]. This function is useful, however, to pass as an argument</code>
<code>;;; to higher-order functions, since #'make-array, #'array, and #'list</code>
<code>;;; won't work.</code>
<code>(defun array (&amp;rest args)</code>
<code>  "Return the unmodified arguments array."</code>
<code>  args)</code>
<code></code>
<code>(defun curry (fn &amp;rest curried-args)</code>
<code>  "Bind the first N `args' of `fn'."</code>
<code>  ;; We could just delegate to JavaScript's Function.prototype.bind().</code>
<code>  (lambda (&amp;rest rest-args)</code>
<code>    (apply fn (append curried-args rest-args))))</code>
<code></code>
<code>(defun flip (fn)</code>
<code>  "Reverse the order of arguments for 2-ary function `fn'."</code>
<code>  (lambda (a b) (fn b a)))</code>
<code></code>
<code>(defun numeric-sort-by! (key table)</code>
<code>  "Numerically sort `table' on `key' in descending order."</code>
<code>  (chain table (sort (lambda (a b)</code>
<code>                       (- (+ (getprop b key)) (+ (getprop a key)))))))</code>
<code></code>
<code>(defun take (n array)</code>
<code>  "Take the first `n' items from `array'."</code>
<code>  (chain array (slice 0 n)))</code>
<code></code>
<code>(defun zip (&amp;rest args)</code>
<code>  (apply #'mapcar #'array args))</code>
<code></code>
<code>(defun make-object-from (key-value-pairs)</code>
<code>  "Construct an Object from `key-value-pairs'.</code>
<code></code>
<code>Example:</code>
<code></code>
<code>(make-object-from ([] (a 1) (b 2) (c 3)))</code>
<code>-&gt; {a: 1, b: 2, c: 3}"</code>
<code>  (let ((o (create)))</code>
<code>    (dolist (kv key-value-pairs o)</code>
<code>      (setf (getprop o (@ kv 0)) (@ kv 1)))))</code>
</pre>
</div>

<p>
Next comes the code for fetching the CSV file and parsing it into an
array of objects. Note that even though Parenscript doesn't know
anything about ES6, there is no problem using Promises or the fetch
API, since they are just regular objects and/or function calls.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(defun fetch-text (url)</code>
<code>  "Fetch `url' and return the response body as text."</code>
<code>  (chain (fetch url)</code>
<code>         (then (lambda (response) (chain response (text))))</code>
<code>         (catch (lambda (error) (throw error)))))</code>
<code></code>
<code>(defun parse-csv (csv-string &amp;optional (numeric-columns (array)))</code>
<code>  "Parse `csv-string' into an array of objects.</code>
<code></code>
<code>The first line of the `csv-string' is expected to contain the</code>
<code>header. Each line of the csv file is then parsed into an object with</code>
<code>properties taken from the header line.</code>
<code></code>
<code>Values for columns in `numeric-colums' are stored as numbers, rather</code>
<code>than strings.</code>
<code></code>
<code>Example:</code>
<code>(parse-csv \"a,b,c\n1,2,3\n4,5,6\" '(\"a\" \"b\"))</code>
<code>-&gt; [{a: 1, b: 2, c: \"3\"}, {a: 4, b: 5, c: \"6\"}]"</code>
<code>  (flet ((convert (alist)</code>
<code>           ;; Note that alist is not a true a-list, since JavaScript</code>
<code>           ;; doesn't have conses. It's just a two-element array.</code>
<code>           (map (lambda (kv)</code>
<code>                  (destructuring-bind (key value) kv</code>
<code>                    (if (member key numeric-columns)</code>
<code>                        (list key (+ value))</code>
<code>                        kv)))</code>
<code>                alist)))</code>
<code>    (let* ((lines (chain csv-string (split #\newline)))</code>
<code>           (columns (chain lines (shift) (split #\,))))</code>
<code>      (map (lambda (line)</code>
<code>             (make-object-from (convert (zip columns (chain line (split #\,))))))</code>
<code>           lines))))</code>
</pre>
</div>

<p>
The CSV parser is fragile and will break if you give it a malformed
file or something it's not expecting like quoted values,
leading/trailing whitespace, etc. But for the purpose of this example,
it does the job. Note that I explicitly provide a default value for
the optional argument <code>numeric-columns</code>, like so: <code>&amp;optional
(numeric-columns (array))</code>. In my first attempt to define the
function, I instead wrote <code>&amp;optional numeric-columns</code>. In Common Lisp,
this would cause <code>numeric-colums</code> to be <code>nil</code> if the caller doesn't
provide it, but in Parenscript, the resulting JavaScript variable is
<code>undefined</code>, which causes an error when I later call <code>(member key
numeric-columns)</code>. In Common Lisp, <code>nil</code> is synonymous with the empty
list, so <code>(member key nil)</code> is fine and always returns <code>nil</code>. By
providing the default value of an empty array in the Parenscript code,
I avoid the undefined variable error. Alternatively, I could use
Parenscript's <code>defined</code> macro to first test whether <code>numeric-columns</code>
is defined before calling <code>member</code>.
</p>

<p>
Now that I can fetch and parse the CSV file, I need to write the
functions for drawing the SVG graph. This code isn't very interesting.
It's an imperative blob that creates SVG DOM elements and sets their
attributes, with magic constants and offsets used here and there for
alignment. This set of functions puts the <i>dirty</i> in
<i>quick-and-dirty</i>.  Again, the point of this example is just to write
a bit more Parenscript, not to recreate d3.js or plotly.js. In the
next example, I'll use plotly.js to plot the same data, for a more
real-world example.
</p>

<p>
I start out with a handful of convenience macros to make creating svg
elements less verbose and more "lispy." These could just as well be
functions, and probably should be. But the macros are simple enough
that making them macros instead of functions isn't too egregious. In
fact, since I always recompile the whole Parenscript file, this
removes one of the major drawbacks of macros, namely the need to
recompile all macro call sites any time the macro definition
changes. And since I'm only having fun with Parenscript, why not
indulge in few gratuitous, zero-cost abstractions?
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(defvar +svg-ns+ "http://www.w3.org/2000/svg")</code>
<code></code>
<code>(defmacro create-svg-element (tag-name)</code>
<code>  `(chain document (create-element-n-s +svg-ns+ ,tag-name)))</code>
<code></code>
<code>(defmacro set-attr (element attr value)</code>
<code>  `(chain ,element (set-attribute ,attr ,value)))</code>
<code></code>
<code>(defmacro append-child. (element child)</code>
<code>  `(chain ,element (append-child ,child)))</code>
</pre>
</div>

<p>
Next comes the top-level drawing function that is responsible for
overall layout. It calls out to subroutines to create the various
graph components. I set the svg element's <code>viewBox</code> attribute to give
myself a scale-independent canvas on which to place elements. The
browser is then free to scale the svg element to fit in the available
layout and will preserve the aspect ratio defined by the <code>viewBox</code>.
</p>

<p>
<a id="orgb3638bf"></a>
</p>

<p>
One implementation note: Due to a bug in the implementation of
<code>reduce</code>, I had to pass -1 rather than 0 as the <code>init</code> argument in the
call to <code>reduce</code>, below. JavaScript has had <code>Array.prototype.reduce</code>
since ECMAScript 5.1 / JS 1.8, so I could just use that instead, but
it was easy to work around the bug by supplying -1 as the <code>init</code>
value, so I stuck with the <code>reduce</code> provided by
<code>*ps-lisp-library*</code>. See the section <a href="#bugs-oddities">Bugs &amp; Oddities</a>, below, for more
info on the <code>reduce</code> bug.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(defun draw-svg-bar-chart (svg-id table)</code>
<code>  "Draw a bar chart from the data in `table' on the svg element given</code>
<code>by `svg-id'."</code>
<code>  (let* ((svg-element (chain document (get-element-by-id svg-id)))</code>
<code>         (svg-height 100)</code>
<code>         (svg-width 500)</code>
<code>         (view-box (chain (list 0 0 svg-width svg-height) (join " ")))</code>
<code>         ;; Reserve h-offset pixels at the top for a title and</code>
<code>         ;; w-offset pixels on the left for the y-axis and label.</code>
<code>         (h-offset 20)</code>
<code>         (w-offset 50)</code>
<code>         (max-height (- svg-height h-offset))</code>
<code>         ;; Cannot use 0 as the init value since 0 is falsey in</code>
<code>         ;; JavaScript! See the implementation of reduce for why. Note</code>
<code>         ;; that reduce is defined in *ps-lisp-library*.</code>
<code>         (max-value (reduce (lambda (acc row)</code>
<code>                              (max acc (getprop row "total exports")))</code>
<code>                            table -1)))</code>
<code>    (set-attr svg-element "viewBox" view-box)</code>
<code>    (flet ((svg-append-all (&amp;rest elements)</code>
<code>             (dolist (element elements)</code>
<code>               (append-child. svg-element element))))</code>
<code>      (svg-append-all</code>
<code>       ;; Y-axis goes first so grid lines are layered at the bottom.</code>
<code>       (make-y-axis</code>
<code>        :w-offset w-offset</code>
<code>        :width svg-width</code>
<code>        :height svg-height</code>
<code>        :tick-scale (/ max-value max-height))</code>
<code>       (make-plot-title</code>
<code>        "Top 25 US States by Agriculture Exports (2011)"</code>
<code>        ;; Title is centered on the x position.</code>
<code>        :x (+ w-offset (/ (- svg-width w-offset) 2))</code>
<code>        :y h-offset)</code>
<code>       (make-y-label</code>
<code>        "Millions USD"</code>
<code>        ;; Label is rotated 90 deg, so x and y are "swapped"</code>
<code>        :x (- (/ svg-height 2))</code>
<code>        :y h-offset)</code>
<code>       (make-bars</code>
<code>        "code" "state" "total exports" table</code>
<code>        :width (- svg-width w-offset)</code>
<code>        :height svg-height</code>
<code>        :value-scale (/ max-height max-value)</code>
<code>        :x w-offset)))))</code>
</pre>
</div>

<p>
Next, here is the source for <code>make-plot-title</code>. I won't list the
sources for <code>make-y-label</code>, <code>make-y-axis</code>, and <code>make-bars</code> since
they're all pretty similar; they all just create some SVG elements and
twiddle their attributes. You can find them all in the file
<a href="parenscript.lisp">parenscript.lisp</a>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(defun make-plot-title</code>
<code>    (title &amp;key (fill "grey") (font-size "10pt") (text-anchor "middle") (x 0) (y 0))</code>
<code>  (let ((plot-title (create-svg-element "text")))</code>
<code>    (setf (@ plot-title id) "plot-title")</code>
<code>    (setf (@ plot-title text-content) title)</code>
<code>    (setf (@ plot-title style font-size) font-size)</code>
<code>    (set-attr plot-title "x" x)</code>
<code>    (set-attr plot-title "y" y)</code>
<code>    (set-attr plot-title "fill" fill)</code>
<code>    (set-attr plot-title "text-anchor" text-anchor)</code>
<code>    plot-title))</code>
</pre>
</div>

<p>
Finally, here is the Promise chain to string it all together.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(chain (fetch-text "2011_us_ag_exports.csv")</code>
<code>       (then (curry (flip parse-csv) '("total exports")))</code>
<code>       (then (curry numeric-sort-by! "total exports"))</code>
<code>       (then (curry take 25))</code>
<code>       (then (curry draw-svg-bar-chart "svg-chart")))</code>
</pre>
</div>
</div>
</div>

<div id="outline-container-example-3-fun-with-plotly.js" class="outline-3">
<h3 id="example-3-fun-with-plotly.js">Example 3: Fun with Plotly.js</h3>
<div class="outline-text-3" id="text-example-3-fun-with-plotly.js">
<p>
In this last example, I'll plot the same data from <a href="#example-2-fun-with-svg">example 2</a>, this
time letting plotly.js do the heavy lifting. The Parenscript code for
this example will be minimal, but it will give a feel for what it's
like to use a JavaScript library from Parenscript. I'll start with a
bar chart, similar to the one above. To get started, I just include
Plotly.js, like so:
</p>

<div class="org-src-container">
<pre class="src src-html"><code>&lt;script src="https://cdn.plot.ly/plotly-1.36.1.min.js"&gt;&lt;/script&gt;</code>
</pre>
</div>
</div>

<div id="outline-container-example-3.1-plotly-bar-chart" class="outline-4">
<h4 id="example-3.1-plotly-bar-chart">Example 3.1: Plotly bar chart</h4>
<div class="outline-text-4" id="text-example-3.1-plotly-bar-chart">
<script src="https://cdn.plot.ly/plotly-1.36.1.min.js"></script>
<div class="fetch-warning"></div>
<div id="plotly-bar" class="wide-graph"></div>

<p>
As expected, the plotly bar chart is a lot nicer on the eyes than my
hand-rolled SVG chart, above. And, indeed, so is the code to produce
it.
</p>

<p>
<a id="org5b904e3"></a>
</p>
<div class="org-src-container">
<pre class="src src-lisp"><code>;;; This macro is analogous to Parenscript's `[]' macro. That is,</code>
<code>;;; `{}.' is to `create' as `[]' is to `array'. Note that Parenscript</code>
<code>;;; already defines `{}' as a symbol-macro that expands to (create);</code>
<code>;;; hence, this macro has a trailing period to avoid the Parenscript</code>
<code>;;; compiler warning about redefining `{}'.</code>
<code>;;;</code>
<code>;;; Actually, because Parenscript's `{}' is a symbol-macro, we *could*</code>
<code>;;; name this macro `{}', and SBCL at least allows both to co-exist</code>
<code>;;; peacefully. If the `{}' appears in the function position, this</code>
<code>;;; macro expansion is used; if it appears anywhere else, the</code>
<code>;;; symbol-macro expansion is used. But the Parenscript compiler</code>
<code>;;; warnings are annoying, so better to just use a unique name here.</code>
<code>(defmacro {}. (&amp;rest args)</code>
<code>  "Create nested object literals."</code>
<code>  `(create ,@(mapcar (lambda (arg)</code>
<code>                       (if (and (consp arg) (not (equal '{}. (car arg))))</code>
<code>                           (cons '{}. arg)</code>
<code>                           arg))</code>
<code>                     args)))</code>
<code></code>
<code>(defun extract-column (column table)</code>
<code>  "Return an array of the values for `column' in `table'."</code>
<code>  (map (lambda (row) (getprop row column)) table))</code>
<code></code>
<code>(defun draw-plotly-bar-chart (chart-id table)</code>
<code>  (let ((layout ({}. :title "Top 25 US States by Agriculture Exports (2011)"</code>
<code>                     :yaxis (:title "Millions USD")))</code>
<code>        (data (list (create :x (extract-column "code" table)</code>
<code>                            :y (extract-column "total exports" table)</code>
<code>                            :text (extract-column "state" table)</code>
<code>                            :type "bar"))))</code>
<code>    (chain -plotly (plot chart-id data layout))))</code>
<code></code>
<code>(chain (fetch-text "2011_us_ag_exports.csv")</code>
<code>       (then (curry (flip parse-csv) '("total exports")))</code>
<code>       (then (curry numeric-sort-by! "total exports"))</code>
<code>       (then (curry take 25))</code>
<code>       (then (curry draw-plotly-bar-chart "plotly-bar")))</code>
</pre>
</div>

<p>
Now that I've got two pieces of code producing more-or-less the same
bar chart, I'm starting to see some code duplication. I was tempted to
define some global variables and helper functions, so that I don't
have to fetch an parse the CSV file twice, for example, or keep typing
out the chart title and y-axis label every time. But for expository
purposes, I think it's actually clearer with a bit of code
duplication, so I'm leaving it.
</p>

<p>
See the section <a href="#bugs-oddities">Bugs &amp; Oddities</a>, below, for more about the <code>{}.</code>
macro.
</p>
</div>
</div>

<div id="outline-container-example-3.2-plotly-choropleth" class="outline-4">
<h4 id="example-3.2-plotly-choropleth">Example 3.2: Plotly choropleth</h4>
<div class="outline-text-4" id="text-example-3.2-plotly-choropleth">
<p>
Finally, here is a choropleth of the same data from the bar charts
above, only all 50 states this time. This example comes straight out
of the plotly.js docs.
</p>

<div class="fetch-warning"></div>
<div id="plotly-choropleth" class="wide-graph"></div>
<script defer src="parenscript.js"></script>

<div class="org-src-container">
<pre class="src src-lisp"><code>(defun draw-plotly-choropleth (chart-id table)</code>
<code>  (let ((layout ({}. :title "US Agriculture Exports by State (2011)"</code>
<code>                     :geo (:scope "usa"</code>
<code>                                  :showlakes t</code>
<code>                                  :lakecolor "rgb(255,255,255)")))</code>
<code>        (data (list (create :type "choropleth"</code>
<code>                            :locationmode "USA-states"</code>
<code>                            :locations (extract-column "code" table)</code>
<code>                            :z (extract-column "total exports" table)</code>
<code>                            :text (extract-column "state" table)</code>
<code>                            :zmin 0</code>
<code>                            :zmax 17000</code>
<code>                            :colorbar ({}. :title "Millions USD"</code>
<code>                                           :thickness 0.2)</code>
<code>                            :colorscale ([] (0 "rgb(242,240,247)")</code>
<code>                                            (0.2 "rgb(218,218,235)")</code>
<code>                                            (0.4 "rgb(188,189,220)")</code>
<code>                                            (0.6 "rgb(158,154,200)")</code>
<code>                                            (0.8 "rgb(117,107,177)")</code>
<code>                                            (1 "rgb(84,39,143)"))</code>
<code>                            :marker ({}. :line (:color "rgb(255,255,255)"</code>
<code>                                                       :width 2))))))</code>
<code>    (chain -plotly (plot chart-id data layout ({}. :show-link false)))))</code>
<code></code>
<code>(chain (fetch-text "2011_us_ag_exports.csv")</code>
<code>       (then (curry (flip parse-csv) '("total exports")))</code>
<code>       (then (curry draw-plotly-choropleth "plotly-choropleth")))</code>
</pre>
</div>

<p>
As you can see, calling third-party JavaScript libraries from
Parenscript is frictionless and requires zero boilerplate.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-bugs-oddities" class="outline-2">
<h2 id="bugs-oddities">Bugs &amp; Oddities</h2>
<div class="outline-text-2" id="text-bugs-oddities">
<p>
In this section, I note small bugs, rough edges, and implementation
details that caught my attention. Some of these are things I might
consider filing an issue or opening a pull request for on
github. Others aren't really bugs, just things I found interesting.
</p>
</div>

<div id="outline-container-reduce-sometimes-ignores-its-init-argument" class="outline-3">
<h3 id="reduce-sometimes-ignores-its-init-argument"><code>reduce</code> sometimes ignores its <code>init</code> argument</h3>
<div class="outline-text-3" id="text-reduce-sometimes-ignores-its-init-argument">
<p>
Update(May 2019): this now <a href="https://github.com/vsedach/Parenscript/issues/40">fixed</a>.
</p>

<p>
As I <a href="#orgb3638bf">noted above</a>, there appears to be a bug in the implementation of
<code>reduce</code> in <code>*ps-lisp-library*</code> which ignores its <code>init</code> argument
whenever the caller passes something that evaluates as false in
JavaScript. The <code>init</code> argument is sometimes ignored because <code>reduce</code>
contains an expression to initialize the accumulator that compiles
down to the following JavaScript:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><code>acc = init ? init : list[0]</code>
</pre>
</div>

<p>
So, if the caller supplies an <code>init</code> value that JavaScript considers
false &#x2013; like <code>0</code>, <code>""</code>, or <code>false</code> to name a few &#x2013; then then <code>acc</code>
will get initialized to the first list item, rather than <code>init</code>. That
is, the conditional should test whether <code>init</code> is <code>undefined</code>
explicitly, rather than any false value.
</p>

<p>
Here are some examples from the browser's JS console demonstrating the
bug:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><code>reduce((acc, e) =&gt; acc * e, [1,2,3,4,5], 0)           /* expect 0 */</code>
<code>--&gt; 120</code>
<code>reduce((acc, e) =&gt; acc &amp;&amp; e, [true,true,true], false) /* expect false */</code>
<code>--&gt; true</code>
<code>reduce((acc,e) =&gt; acc, ["foo", "bar"], "")            /* expect "" */</code>
<code>--&gt; "foo"</code>
</pre>
</div>
</div>
</div>

<div id="outline-container-let-ignores-garbage-in-binding-forms" class="outline-3">
<h3 id="let-ignores-garbage-in-binding-forms"><code>let</code> ignores garbage in binding forms</h3>
<div class="outline-text-3" id="text-let-ignores-garbage-in-binding-forms">
<p>
Parenscript's implementation of <code>let</code> ignores extra garbage at the end
of each binding form. For example:
</p>

<pre class="example" id="org1227c80">
<code>;; Parenscript         /* JavaScript */</code>
<code>(let ((x 4 (/ 0 0)))   (function () {</code>
<code>  x)                      var x = 4;</code>
<code>                          return x;</code>
<code>                       })();</code>
</pre>

<p>
For comparison, SBCL, CCL, and CLISP all signals errors complaining
that the let binding is malformed. Of course, it's not really fair to
compare Parenscript to production-grade Common Lisp implementations, I
just happened to notice it when reading over Parenscript's <code>let</code>
implementation. Besides, who's to say this is a bug and not a feature!
</p>
</div>
</div>

<div id="outline-container-psencode-js-identifier-deprecation-warnings" class="outline-3">
<h3 id="psencode-js-identifier-deprecation-warnings"><code>ps::encode-js-identifier</code> deprecation warnings</h3>
<div class="outline-text-3" id="text-psencode-js-identifier-deprecation-warnings">
<p>
Update(May 2019): this is now <a href="https://github.com/vsedach/Parenscript/issues/41">fixed</a>.
</p>

<p>
The implementation of <code>ps::encode-js-identifier</code> in <code>utils.lisp</code>
issues a warning if the user creates an identifier with an embedded
dot (<code>.</code>) or sqaure brackets (<code>[]</code>), which is a useful shorthand for
referencing object properties or indexing into arrays (and was
presumably supported in older versions of Parenscript). For example,
<code>foo.bar</code> or <code>foobar[3]</code>. I believe the current recommendation is to
use the <code>@</code> macro instead, like so: <code>(@ foo bar)</code> or <code>(@ foobar
3)</code>. However, <code>ps::encode-js-identifier</code> will only issue the warning
about embedded dot and/or square brackets if certain other special
characters are present in the identifier name which cause Parenscript
name mangling rules to kick in. I assume this is a bug, and the
intention is to always warn about embedded dot/bracket characters, but
I'm not sure.
</p>

<p>
An example might help clarify. In the following SLIME-REPL session,
I'd expect <code>"foo.bar"</code> and <code>"foobar[3]"</code> to also generate warnings.
</p>

<pre class="example" id="orgfeafd57">
<code>FUN-WITH-PS&gt; (ps::encode-js-identifier "foo.bar")</code>
<code>"FOO.BAR"</code>
<code>FUN-WITH-PS&gt; (ps::encode-js-identifier "foo.bar?")</code>
<code>WARNING:</code>
<code>   Symbol foo.bar? contains one of '.[]' - this compound naming convention is no longer supported by Parenscript!</code>
<code>"foo.barwhat"</code>
<code>FUN-WITH-PS&gt; (ps::encode-js-identifier "foobar[3]")</code>
<code>"FOOBAR[3]"</code>
<code>FUN-WITH-PS&gt; (ps::encode-js-identifier "foo-bar[3]")</code>
<code>WARNING:</code>
<code>   Symbol foo-bar[3] contains one of '.[]' - this compound naming convention is no longer supported by Parenscript!</code>
<code>"fooBar[3]"</code>
</pre>

<p>
Here is the relevant portion of <code>ps::encode-js-identifier</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(let ((cache (make-hash-table :test 'equal)))</code>
<code>  (defun encode-js-identifier (identifier)</code>
<code>    "Given a string, produces to a valid JavaScript identifier by</code>
<code>following transformation heuristics case conversion. For example,</code>
<code>paren-script becomes parenScript, *some-global* becomes SOMEGLOBAL."</code>
<code>    (or (gethash identifier cache)</code>
<code>        (setf (gethash identifier cache)</code>
<code>              (cond ((some (lambda (c) (find c "-*+!?#@%/=:&lt;&gt;^")) identifier)</code>
<code>                     (let ((lowercase t)</code>
<code>                           (all-uppercase nil))</code>
<code>                       (when (and (not (string= identifier "[]")) ;; HACK</code>
<code>                                  (find-if (lambda (x) (find x '(#\. #\[ #\]))) identifier))</code>
<code>                         (warn "Symbol ~A contains one of '.[]' - this compound naming convention is no longer supported by Parenscript!"</code>
<code>                               identifier))</code>
<code>                         ...</code>
</pre>
</div>

<p>
A couple of things to note:
</p>

<ul class="org-ul">
<li>the <code>cond</code> test ensures that <code>identifier</code> contains at least one of
the characters <code>-*+!?#@%/=:&lt;&gt;^</code>
<ul class="org-ul">
<li>therefore, the <code>(string= identifier "[]")</code> test can never be true</li>
<li>therefore, the warning about an identifier containing a period
and/or square brackets can only be triggered if it also contains
one of the characters <code>-*+!?#@%/=:&lt;&gt;^</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-array-argument-punning" class="outline-3">
<h3 id="array-argument-punning">Array argument punning</h3>
<div class="outline-text-3" id="text-array-argument-punning">
<p>
This one is kind of fun. It turns out that if you want to pass an
array literal as an argument of a function, you can use an almost
identical syntax to JavaScript arrays, just without the commas. For
example:
</p>

<pre class="example" id="org5a67b6c">
<code>;; Parenscript             /* JavaScript */</code>
<code>(some-fn [a b 1 2])        someFn([a, b, 1, 2]);</code>
</pre>

<p>
This isn't documented in the Parenscript reference. I think what's
going on here is that Parenscript thinks it's compiling a function
call with four separate arguments, where the first argument happens to
be named <code>[a</code> and the last happens to be <code>2]</code>. We can see this more
clearly if we place spaces around the square brackets, in which case
we get:
</p>

<pre class="example" id="org65ea5fe">
<code>;; Parenscript             /* JavaScript */</code>
<code>(some-fn [ a b 1 2 ])      someFn([, a, b, 1, 2, ]);</code>
</pre>

<p>
Now Parenscript compiles it as a six-argument function where the first
argument is <code>[</code> and the last is <code>]</code>.
</p>

<p>
This hack works for nested arrays as well:
</p>

<pre class="example" id="org0d84ed9">
<code>;; Parenscript               /* JavaScript */</code>
<code>(some-fn [[a b] 2 [c d] e])  someFn([[a, b], 2, [c, d], e]);</code>
<code>(some-fn [[a [b [c]]]]))     someFn([[a, [b, [c]]]]);</code>
</pre>

<p>
This quirk isn't documented in the Parenscript reference, so I assume
it's a kind of "happy accident" since <code>[a</code> and <code>2]</code> aren't actually
valid JavaScript identifiers. But maybe it's intentional? Who knows?
In any case, you should probably just use the <code>[]</code> macro (see the next
section) for creating nested arrays.
</p>
</div>
</div>

<div id="outline-container-vs" class="outline-3">
<h3 id="vs"><code>[]</code> vs <code>{}</code></h3>
<div class="outline-text-3" id="text-vs">
<p>
There are a couple of little asymmetries with respect to <code>[]</code> and <code>{}</code>
that caught me off guard, summarized in the following examples:
</p>

<pre class="example" id="org9ff2546">
<code>;; Parenscript               /* JavaScript */</code>
<code>(defvar *my-array* [])       var MYARRAY = [];</code>
<code>(defvar *also-array* '[])    var ALSOARRAY = [];</code>
<code></code>
<code>(defvar *my-object* {})      var MYOBJECT = {  };</code>
<code>(defvar *my-string* '{})     var MYSTRING = '{}';</code>
<code></code>
<code>([] :make (nested []))       ['make', [nested, []]];</code>
<code>({} :not (like []))          {}('not', like([]));</code>
</pre>

<p>
Both <code>[]</code> and <code>'[]</code> in Parenscript are compiled to the empty
JavaScript array literal: <code>[]</code>. So you might expect <code>{}</code> and <code>'{}</code> to
behave similarly. While Parenscript does compile <code>{}</code> to the empty
JavaScript object literal <code>{ }</code>, the quoted form <code>'{}</code> is instead
compiled down to a string <code>'{}'</code>. This is because Parenscript
special-cases <code>'[]</code> to expand to <code>(array)</code>, whereas there is no
special handling for <code>'{}</code>.  Here are the relevant bits from
Parenscript's <code>quote</code> in <code>special-operators.lisp</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(define-expression-operator quote (x)</code>
<code>  (flet ((quote% (expr) (when expr `',expr)))</code>
<code>    (compile-expression</code>
<code>     (typecase x</code>
<code>       ...</code>
<code>       ((or null (eql [])) '(array))</code>
<code>       ...</code>
<code>       (symbol (symbol-to-js-string x))</code>
<code>       ... ))))</code>
</pre>
</div>

<p>
The unquoted forms <code>[]</code> and <code>{}</code> are also handled differently by the
Parenscript compiler, though both compile down to the corresponding
JavaScript literal syntax. Parenscript simply defines <code>{}</code> as a
symbol-macro that expands to <code>(create)</code>, whereas <code>[]</code> is treated as an
identifier, as far as I can tell. Of course, <code>[]</code> isn't a valid
JavaScript identifier, and treating it like one allows for nonsense
like:
</p>

<pre class="example" id="org1e25d51">
<code>;; Parenscript          /* JavaScript */</code>
<code>(let (([] 'huh))        (function () {</code>
<code>   [])                     var [] = 'huh';</code>
<code>                           return [];</code>
<code>                        })();</code>
<code></code>
<code>(defvar [] 'whoops)     var [] = 'whoops';</code>
</pre>

<p>
Thanks to ES6's destructuring assignment, neither of these causes a
JavaScript <code>SyntaxError</code> in modern browsers; the assignment is just
ignored, as far as I can tell. Replacing <code>[]</code> with <code>{}</code> in the above
two examples results in the following:
</p>

<pre class="example" id="orgd70a15e">
<code>;; Parenscript          /* JavaScript */</code>
<code>(let (({} 'huh))        (function () {</code>
<code>   {})                     var {}1 = 'huh';</code>
<code>                           return {}1;</code>
<code>                        })();</code>
<code>                        /* JavaScript error:</code>
<code>                             Uncaught SyntaxError: Missing initializer in destructuring declaration */</code>
<code></code>
<code>;; Does not compile.</code>
<code>;; Lisp error:</code>
<code>;;   The value</code>
<code>;;     (CREATE)</code>
<code>;;   is not of type</code>
<code>;;     SYMBOL</code>
<code>;;   [Condition of type TYPE-ERROR]</code>
<code>(defvar {} 'whoops)</code>
</pre>

<p>
Note the trailing <code>1</code> in the generated JavaScript when let-binding
<code>{}</code>.  This is due to Parenscript's <code>maybe-rename-lexical-var</code>, which
finds <code>{}</code> in <code>*symbol-macro-env*</code>, and replaces it with a gensym.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><code>(defun maybe-rename-lexical-var (x symbols-in-bindings)</code>
<code>  (when (or (member x *enclosing-lexicals*)</code>
<code>            (member x *enclosing-function-arguments*)</code>
<code>            (when (boundp '*used-up-names*)</code>
<code>              (member x *used-up-names*))</code>
<code>            (lookup-macro-def x *symbol-macro-env*)</code>
<code>            (member x symbols-in-bindings))</code>
<code>    (ps-gensym (symbol-name x))))</code>
</pre>
</div>

<p>
Defining a symbol-macro a-la <code>{}</code> seems like a cleaner solution, so
presumably there is some reason why <code>[]</code> is handled differently.
Possibly because Parenscript defines a macro named <code>[]</code>? Is it "safe"
(i.e. portable) to define both a macro and symbol-macro with same name
in Common Lisp? None of SBCL, CCL, or CLISP complain if I do. A quick
skim of the relevant sections in the HyperSpec doesn't seem to
explicitly rule it out, and indeed this seems analogous to defining a
function and a variable with the same name, which is fair game in
Common Lisp.
</p>

<p>
The final asymmetry I'll note between <code>[]</code> and <code>{}</code> is that while
Parenscript defines a macro named <code>[]</code> to help with creating nested
arrays, there is no corresponding <code>{}</code> macro to create nested object
literals. That is, while the form <code>([] 1 (2 foo) 3)</code> compiles to <code>[1,
[2, foo], 3]</code>, the form <code>({} :a (:b c))</code> compiles to <code>{}('a',
'b'(c))</code>, not <code>{ 'a': { 'b': c } }</code>, as you might hope. Of course,
it's possible to define your own <code>{}</code> macro for creating nested
objects, and that's just what I did in <a href="#org5b904e3">Example 3.1</a>, above.
</p>
</div>
</div>
</div>

<div id="outline-container-takeaways" class="outline-2">
<h2 id="takeaways">Takeaways</h2>
<div class="outline-text-2" id="text-takeaways">
<p>
Despite a few small bugs and rough edges, Parenscript delivers on its
promise of providing a Common Lisp-ish syntax for writing JavaScript,
complete with the full power of macros for your JavaScripting
enjoyment.  Alas, it's only subset of Common Lisp, so it feels more
like writing JavaScript with a lispy syntax than it feels like writing
Common Lisp, but that's still pretty cool! I would consider using
Parenscript again for small side-projects with traditional
server-side-rendered web interfaces where I was already using Common
Lisp on the server-side. I probably wouldn't try to use Parenscript
for creating a snazzy, user-interaction-heavy SPA / PWA with
React. Then again, as you can probably tell from this website, I
wouldn't try creating such a webapp at all!
</p>

<p>
In keeping with the stream-of-consciousness nature of this post, I'll
now ramble off a list of Parenscript pros and cons.
</p>
</div>

<div id="outline-container-pros" class="outline-3">
<h3 id="pros">Pros</h3>
<div class="outline-text-3" id="text-pros">
<ul class="org-ul">
<li>Macros</li>
<li>Trivial to call third-party JavaScript libraries from Parenscript
without requiring any boilerplate.</li>
<li>Parenscript generates very readable JavaScript, with no runtime
dependencies. Most of the time, you can guess more-or-less what
JavaScript will be produced for a given Parenscript expression.</li>
<li>Parenscript implementation is relatively small and easy to
understand.  Only ~4k total lines of code, of which ~700
lines are in a file that just exports a bunch of JavaScript symbols,
and another ~300 lines are in Parenscript's implementation of
the <code>loop</code> macro. So ~3k lines of very readable Common Lisp for
the meat of the transpiler.</li>
<li>For users who already know and love Common Lisp but don't know much
JavaScipt, Parenscript allows you to stay in the comfort zone and
avoid JavaScript fatigue.</li>
<li>Development moves slowly, so stuff rarely breaks.</li>
</ul>
</div>
</div>

<div id="outline-container-cons" class="outline-3">
<h3 id="cons">Cons</h3>
<div class="outline-text-3" id="text-cons">
<ul class="org-ul">
<li>Parenscript doesn't have <code>cons</code>! (that pun was too good to pass up).</li>
<li>Still no support for cool ES6+ stuff like async/await, generators,
etc.</li>
<li>Though doable, doesn't cater to users who aren't using Common Lisp
on the server.</li>
<li>Parenscript is a not-super-popular open-source project, with all the
pitfalls that usually entails.</li>
<li>Development moves slowly, so stuff rarely gets fixed.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr>
<p class="date">Created: 2018-05-04</p>
<p class="date">Last modified: 2024-04-11</p>
<p class="validation"></p>
</div>
</body>
</html>
